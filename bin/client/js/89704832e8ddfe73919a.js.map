{"version":3,"sources":["webpack:////home/badou/Desktop/heroku/bebouc/node_modules/history/es/createBrowserHistory.js","webpack:////home/badou/Desktop/heroku/bebouc/node_modules/history/es/createHashHistory.js"],"names":["warning__WEBPACK_IMPORTED_MODULE_0__","__webpack_require__","warning__WEBPACK_IMPORTED_MODULE_0___default","n","invariant__WEBPACK_IMPORTED_MODULE_1__","invariant__WEBPACK_IMPORTED_MODULE_1___default","_LocationUtils__WEBPACK_IMPORTED_MODULE_2__","_PathUtils__WEBPACK_IMPORTED_MODULE_3__","_createTransitionManager__WEBPACK_IMPORTED_MODULE_4__","_DOMUtils__WEBPACK_IMPORTED_MODULE_5__","_typeof","Symbol","iterator","obj","constructor","prototype","_extends","Object","assign","target","i","arguments","length","source","key","hasOwnProperty","call","getHistoryState","window","history","state","e","__webpack_exports__","props","undefined","globalHistory","canUseHistory","needsHashChangeListener","_props$forceRefresh","forceRefresh","_props$getUserConfirm","getUserConfirmation","_props$keyLength","keyLength","basename","getDOMLocation","historyState","_ref","_window$location","location","path","pathname","search","hash","createKey","Math","random","toString","substr","transitionManager","setState","nextState","notifyListeners","action","handlePopState","event","handlePop","handleHashChange","forceNextPop","confirmTransitionTo","ok","revertPop","fromLocation","toLocation","toIndex","allKeys","indexOf","fromIndex","delta","go","initialLocation","createHref","listenerCount","checkDOMListeners","isBlocked","push","href","pushState","prevIndex","nextKeys","slice","replace","replaceState","goBack","goForward","block","prompt","unblock","setPrompt","listen","listener","unlisten","appendListener"],"mappings":"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","file":"js/89704832e8ddfe73919a.js","sourcesContent":["var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nimport warning from 'warning';\nimport invariant from 'invariant';\nimport { createLocation } from './LocationUtils';\nimport { addLeadingSlash, stripTrailingSlash, hasBasename, stripBasename, createPath } from './PathUtils';\nimport createTransitionManager from './createTransitionManager';\nimport { canUseDOM, addEventListener, removeEventListener, getConfirmation, supportsHistory, supportsPopStateOnHashChange, isExtraneousPopstateEvent } from './DOMUtils';\n\nvar PopStateEvent = 'popstate';\nvar HashChangeEvent = 'hashchange';\n\nvar getHistoryState = function getHistoryState() {\n  try {\n    return window.history.state || {};\n  } catch (e) {\n    // IE 11 sometimes throws when accessing window.history.state\n    // See https://github.com/ReactTraining/history/pull/289\n    return {};\n  }\n};\n\n/**\n * Creates a history object that uses the HTML5 history API including\n * pushState, replaceState, and the popstate event.\n */\nvar createBrowserHistory = function createBrowserHistory() {\n  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  invariant(canUseDOM, 'Browser history needs a DOM');\n\n  var globalHistory = window.history;\n  var canUseHistory = supportsHistory();\n  var needsHashChangeListener = !supportsPopStateOnHashChange();\n\n  var _props$forceRefresh = props.forceRefresh,\n      forceRefresh = _props$forceRefresh === undefined ? false : _props$forceRefresh,\n      _props$getUserConfirm = props.getUserConfirmation,\n      getUserConfirmation = _props$getUserConfirm === undefined ? getConfirmation : _props$getUserConfirm,\n      _props$keyLength = props.keyLength,\n      keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;\n\n  var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : '';\n\n  var getDOMLocation = function getDOMLocation(historyState) {\n    var _ref = historyState || {},\n        key = _ref.key,\n        state = _ref.state;\n\n    var _window$location = window.location,\n        pathname = _window$location.pathname,\n        search = _window$location.search,\n        hash = _window$location.hash;\n\n\n    var path = pathname + search + hash;\n\n    warning(!basename || hasBasename(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path \"' + path + '\" to begin with \"' + basename + '\".');\n\n    if (basename) path = stripBasename(path, basename);\n\n    return createLocation(path, state, key);\n  };\n\n  var createKey = function createKey() {\n    return Math.random().toString(36).substr(2, keyLength);\n  };\n\n  var transitionManager = createTransitionManager();\n\n  var setState = function setState(nextState) {\n    _extends(history, nextState);\n\n    history.length = globalHistory.length;\n\n    transitionManager.notifyListeners(history.location, history.action);\n  };\n\n  var handlePopState = function handlePopState(event) {\n    // Ignore extraneous popstate events in WebKit.\n    if (isExtraneousPopstateEvent(event)) return;\n\n    handlePop(getDOMLocation(event.state));\n  };\n\n  var handleHashChange = function handleHashChange() {\n    handlePop(getDOMLocation(getHistoryState()));\n  };\n\n  var forceNextPop = false;\n\n  var handlePop = function handlePop(location) {\n    if (forceNextPop) {\n      forceNextPop = false;\n      setState();\n    } else {\n      var action = 'POP';\n\n      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n        if (ok) {\n          setState({ action: action, location: location });\n        } else {\n          revertPop(location);\n        }\n      });\n    }\n  };\n\n  var revertPop = function revertPop(fromLocation) {\n    var toLocation = history.location;\n\n    // TODO: We could probably make this more reliable by\n    // keeping a list of keys we've seen in sessionStorage.\n    // Instead, we just default to 0 for keys we don't know.\n\n    var toIndex = allKeys.indexOf(toLocation.key);\n\n    if (toIndex === -1) toIndex = 0;\n\n    var fromIndex = allKeys.indexOf(fromLocation.key);\n\n    if (fromIndex === -1) fromIndex = 0;\n\n    var delta = toIndex - fromIndex;\n\n    if (delta) {\n      forceNextPop = true;\n      go(delta);\n    }\n  };\n\n  var initialLocation = getDOMLocation(getHistoryState());\n  var allKeys = [initialLocation.key];\n\n  // Public interface\n\n  var createHref = function createHref(location) {\n    return basename + createPath(location);\n  };\n\n  var push = function push(path, state) {\n    warning(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored');\n\n    var action = 'PUSH';\n    var location = createLocation(path, state, createKey(), history.location);\n\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n\n      var href = createHref(location);\n      var key = location.key,\n          state = location.state;\n\n\n      if (canUseHistory) {\n        globalHistory.pushState({ key: key, state: state }, null, href);\n\n        if (forceRefresh) {\n          window.location.href = href;\n        } else {\n          var prevIndex = allKeys.indexOf(history.location.key);\n          var nextKeys = allKeys.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);\n\n          nextKeys.push(location.key);\n          allKeys = nextKeys;\n\n          setState({ action: action, location: location });\n        }\n      } else {\n        warning(state === undefined, 'Browser history cannot push state in browsers that do not support HTML5 history');\n\n        window.location.href = href;\n      }\n    });\n  };\n\n  var replace = function replace(path, state) {\n    warning(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored');\n\n    var action = 'REPLACE';\n    var location = createLocation(path, state, createKey(), history.location);\n\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n\n      var href = createHref(location);\n      var key = location.key,\n          state = location.state;\n\n\n      if (canUseHistory) {\n        globalHistory.replaceState({ key: key, state: state }, null, href);\n\n        if (forceRefresh) {\n          window.location.replace(href);\n        } else {\n          var prevIndex = allKeys.indexOf(history.location.key);\n\n          if (prevIndex !== -1) allKeys[prevIndex] = location.key;\n\n          setState({ action: action, location: location });\n        }\n      } else {\n        warning(state === undefined, 'Browser history cannot replace state in browsers that do not support HTML5 history');\n\n        window.location.replace(href);\n      }\n    });\n  };\n\n  var go = function go(n) {\n    globalHistory.go(n);\n  };\n\n  var goBack = function goBack() {\n    return go(-1);\n  };\n\n  var goForward = function goForward() {\n    return go(1);\n  };\n\n  var listenerCount = 0;\n\n  var checkDOMListeners = function checkDOMListeners(delta) {\n    listenerCount += delta;\n\n    if (listenerCount === 1) {\n      addEventListener(window, PopStateEvent, handlePopState);\n\n      if (needsHashChangeListener) addEventListener(window, HashChangeEvent, handleHashChange);\n    } else if (listenerCount === 0) {\n      removeEventListener(window, PopStateEvent, handlePopState);\n\n      if (needsHashChangeListener) removeEventListener(window, HashChangeEvent, handleHashChange);\n    }\n  };\n\n  var isBlocked = false;\n\n  var block = function block() {\n    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n    var unblock = transitionManager.setPrompt(prompt);\n\n    if (!isBlocked) {\n      checkDOMListeners(1);\n      isBlocked = true;\n    }\n\n    return function () {\n      if (isBlocked) {\n        isBlocked = false;\n        checkDOMListeners(-1);\n      }\n\n      return unblock();\n    };\n  };\n\n  var listen = function listen(listener) {\n    var unlisten = transitionManager.appendListener(listener);\n    checkDOMListeners(1);\n\n    return function () {\n      checkDOMListeners(-1);\n      unlisten();\n    };\n  };\n\n  var history = {\n    length: globalHistory.length,\n    action: 'POP',\n    location: initialLocation,\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    goBack: goBack,\n    goForward: goForward,\n    block: block,\n    listen: listen\n  };\n\n  return history;\n};\n\nexport default createBrowserHistory;","var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nimport warning from 'warning';\nimport invariant from 'invariant';\nimport { createLocation, locationsAreEqual } from './LocationUtils';\nimport { addLeadingSlash, stripLeadingSlash, stripTrailingSlash, hasBasename, stripBasename, createPath } from './PathUtils';\nimport createTransitionManager from './createTransitionManager';\nimport { canUseDOM, addEventListener, removeEventListener, getConfirmation, supportsGoWithoutReloadUsingHash } from './DOMUtils';\n\nvar HashChangeEvent = 'hashchange';\n\nvar HashPathCoders = {\n  hashbang: {\n    encodePath: function encodePath(path) {\n      return path.charAt(0) === '!' ? path : '!/' + stripLeadingSlash(path);\n    },\n    decodePath: function decodePath(path) {\n      return path.charAt(0) === '!' ? path.substr(1) : path;\n    }\n  },\n  noslash: {\n    encodePath: stripLeadingSlash,\n    decodePath: addLeadingSlash\n  },\n  slash: {\n    encodePath: addLeadingSlash,\n    decodePath: addLeadingSlash\n  }\n};\n\nvar getHashPath = function getHashPath() {\n  // We can't use window.location.hash here because it's not\n  // consistent across browsers - Firefox will pre-decode it!\n  var href = window.location.href;\n  var hashIndex = href.indexOf('#');\n  return hashIndex === -1 ? '' : href.substring(hashIndex + 1);\n};\n\nvar pushHashPath = function pushHashPath(path) {\n  return window.location.hash = path;\n};\n\nvar replaceHashPath = function replaceHashPath(path) {\n  var hashIndex = window.location.href.indexOf('#');\n\n  window.location.replace(window.location.href.slice(0, hashIndex >= 0 ? hashIndex : 0) + '#' + path);\n};\n\nvar createHashHistory = function createHashHistory() {\n  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  invariant(canUseDOM, 'Hash history needs a DOM');\n\n  var globalHistory = window.history;\n  var canGoWithoutReload = supportsGoWithoutReloadUsingHash();\n\n  var _props$getUserConfirm = props.getUserConfirmation,\n      getUserConfirmation = _props$getUserConfirm === undefined ? getConfirmation : _props$getUserConfirm,\n      _props$hashType = props.hashType,\n      hashType = _props$hashType === undefined ? 'slash' : _props$hashType;\n\n  var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : '';\n\n  var _HashPathCoders$hashT = HashPathCoders[hashType],\n      encodePath = _HashPathCoders$hashT.encodePath,\n      decodePath = _HashPathCoders$hashT.decodePath;\n\n\n  var getDOMLocation = function getDOMLocation() {\n    var path = decodePath(getHashPath());\n\n    warning(!basename || hasBasename(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path \"' + path + '\" to begin with \"' + basename + '\".');\n\n    if (basename) path = stripBasename(path, basename);\n\n    return createLocation(path);\n  };\n\n  var transitionManager = createTransitionManager();\n\n  var setState = function setState(nextState) {\n    _extends(history, nextState);\n\n    history.length = globalHistory.length;\n\n    transitionManager.notifyListeners(history.location, history.action);\n  };\n\n  var forceNextPop = false;\n  var ignorePath = null;\n\n  var handleHashChange = function handleHashChange() {\n    var path = getHashPath();\n    var encodedPath = encodePath(path);\n\n    if (path !== encodedPath) {\n      // Ensure we always have a properly-encoded hash.\n      replaceHashPath(encodedPath);\n    } else {\n      var location = getDOMLocation();\n      var prevLocation = history.location;\n\n      if (!forceNextPop && locationsAreEqual(prevLocation, location)) return; // A hashchange doesn't always == location change.\n\n      if (ignorePath === createPath(location)) return; // Ignore this change; we already setState in push/replace.\n\n      ignorePath = null;\n\n      handlePop(location);\n    }\n  };\n\n  var handlePop = function handlePop(location) {\n    if (forceNextPop) {\n      forceNextPop = false;\n      setState();\n    } else {\n      var action = 'POP';\n\n      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n        if (ok) {\n          setState({ action: action, location: location });\n        } else {\n          revertPop(location);\n        }\n      });\n    }\n  };\n\n  var revertPop = function revertPop(fromLocation) {\n    var toLocation = history.location;\n\n    // TODO: We could probably make this more reliable by\n    // keeping a list of paths we've seen in sessionStorage.\n    // Instead, we just default to 0 for paths we don't know.\n\n    var toIndex = allPaths.lastIndexOf(createPath(toLocation));\n\n    if (toIndex === -1) toIndex = 0;\n\n    var fromIndex = allPaths.lastIndexOf(createPath(fromLocation));\n\n    if (fromIndex === -1) fromIndex = 0;\n\n    var delta = toIndex - fromIndex;\n\n    if (delta) {\n      forceNextPop = true;\n      go(delta);\n    }\n  };\n\n  // Ensure the hash is encoded properly before doing anything else.\n  var path = getHashPath();\n  var encodedPath = encodePath(path);\n\n  if (path !== encodedPath) replaceHashPath(encodedPath);\n\n  var initialLocation = getDOMLocation();\n  var allPaths = [createPath(initialLocation)];\n\n  // Public interface\n\n  var createHref = function createHref(location) {\n    return '#' + encodePath(basename + createPath(location));\n  };\n\n  var push = function push(path, state) {\n    warning(state === undefined, 'Hash history cannot push state; it is ignored');\n\n    var action = 'PUSH';\n    var location = createLocation(path, undefined, undefined, history.location);\n\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n\n      var path = createPath(location);\n      var encodedPath = encodePath(basename + path);\n      var hashChanged = getHashPath() !== encodedPath;\n\n      if (hashChanged) {\n        // We cannot tell if a hashchange was caused by a PUSH, so we'd\n        // rather setState here and ignore the hashchange. The caveat here\n        // is that other hash histories in the page will consider it a POP.\n        ignorePath = path;\n        pushHashPath(encodedPath);\n\n        var prevIndex = allPaths.lastIndexOf(createPath(history.location));\n        var nextPaths = allPaths.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);\n\n        nextPaths.push(path);\n        allPaths = nextPaths;\n\n        setState({ action: action, location: location });\n      } else {\n        warning(false, 'Hash history cannot PUSH the same path; a new entry will not be added to the history stack');\n\n        setState();\n      }\n    });\n  };\n\n  var replace = function replace(path, state) {\n    warning(state === undefined, 'Hash history cannot replace state; it is ignored');\n\n    var action = 'REPLACE';\n    var location = createLocation(path, undefined, undefined, history.location);\n\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n\n      var path = createPath(location);\n      var encodedPath = encodePath(basename + path);\n      var hashChanged = getHashPath() !== encodedPath;\n\n      if (hashChanged) {\n        // We cannot tell if a hashchange was caused by a REPLACE, so we'd\n        // rather setState here and ignore the hashchange. The caveat here\n        // is that other hash histories in the page will consider it a POP.\n        ignorePath = path;\n        replaceHashPath(encodedPath);\n      }\n\n      var prevIndex = allPaths.indexOf(createPath(history.location));\n\n      if (prevIndex !== -1) allPaths[prevIndex] = path;\n\n      setState({ action: action, location: location });\n    });\n  };\n\n  var go = function go(n) {\n    warning(canGoWithoutReload, 'Hash history go(n) causes a full page reload in this browser');\n\n    globalHistory.go(n);\n  };\n\n  var goBack = function goBack() {\n    return go(-1);\n  };\n\n  var goForward = function goForward() {\n    return go(1);\n  };\n\n  var listenerCount = 0;\n\n  var checkDOMListeners = function checkDOMListeners(delta) {\n    listenerCount += delta;\n\n    if (listenerCount === 1) {\n      addEventListener(window, HashChangeEvent, handleHashChange);\n    } else if (listenerCount === 0) {\n      removeEventListener(window, HashChangeEvent, handleHashChange);\n    }\n  };\n\n  var isBlocked = false;\n\n  var block = function block() {\n    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n    var unblock = transitionManager.setPrompt(prompt);\n\n    if (!isBlocked) {\n      checkDOMListeners(1);\n      isBlocked = true;\n    }\n\n    return function () {\n      if (isBlocked) {\n        isBlocked = false;\n        checkDOMListeners(-1);\n      }\n\n      return unblock();\n    };\n  };\n\n  var listen = function listen(listener) {\n    var unlisten = transitionManager.appendListener(listener);\n    checkDOMListeners(1);\n\n    return function () {\n      checkDOMListeners(-1);\n      unlisten();\n    };\n  };\n\n  var history = {\n    length: globalHistory.length,\n    action: 'POP',\n    location: initialLocation,\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    goBack: goBack,\n    goForward: goForward,\n    block: block,\n    listen: listen\n  };\n\n  return history;\n};\n\nexport default createHashHistory;"],"sourceRoot":""}